[1mdiff --cc adapter_magicstomp.py[m
[1mindex 1f0731e,6f7e86d..0000000[m
[1m--- a/adapter_magicstomp.py[m
[1m+++ b/adapter_magicstomp.py[m
[36m@@@ -77,603 -89,235 +89,563 @@@[m [mclass MagicstompAdapter[m
              "PLATE": 0x02,[m
              "HALL": 0x03,[m
              "SPRING": 0x04,[m
[31m-             "CHURCH": 0x05[m
[32m+             "CHURCH": 0x05,[m
          }[m
[31m-         [m
[31m-         # Mappings des types de modulation[m
[32m+ [m
          self.mod_types = {[m
[31m-             "CHORUS": 0x01,[m
[31m-             "PHASER": 0x02,[m
[31m-             "TREMOLO": 0x03,[m
[31m-             "VIBRATO": 0x04,[m
[31m-             "FLANGER": 0x05[m
[32m+             "CHORUS": "Chorus",[m
[32m+             "PHASER": "Phaser",[m
[32m+             "TREMOLO": "Tremolo",[m
          }[m
[31m-     [m
[31m-     def float_to_magicstomp_value(self, value: float, max_val: int = 127) -> int:[m
[31m-         """[m
[31m-         Convertit une valeur float [0,1] vers une valeur Magicstomp [0,max_val].[m
[31m-         [m
[31m-         Args:[m
[31m-             value: Valeur normalis√©e [0,1][m
[31m-             max_val: Valeur maximale Magicstomp (d√©faut 127)[m
[31m-             [m
[31m-         Returns:[m
[31m-             Valeur Magicstomp[m
[31m-         """[m
[31m-         return int(max(0, min(max_val, round(value * max_val))))[m
[31m-     [m
[31m-     def ms_to_magicstomp_time(self, time_ms: float) -> int:[m
[31m-         """[m
[31m-         Convertit un temps en ms vers la valeur Magicstomp.[m
[31m-         [m
[31m-         Args:[m
[31m-             time_ms: Temps en millisecondes[m
[31m-             [m
[31m-         Returns:[m
[31m-             Valeur Magicstomp pour le temps[m
[31m-         """[m
[31m-         # Magicstomp utilise une √©chelle logarithmique pour les temps[m
[31m-         # Approximation: log(time_ms) * facteur[m
[31m-         if time_ms <= 0:[m
[31m-             return 0[m
[31m-         [m
[31m-         # Mapping approximatif bas√© sur l'√©chelle Magicstomp[m
[31m-         if time_ms <= 50:[m
[31m-             return int(time_ms * 2.54)  # 0-127 pour 0-50ms[m
[31m-         elif time_ms <= 500:[m
[31m-             return int(127 + (time_ms - 50) * 0.28)  # 127-255 pour 50-500ms[m
[31m-         else:[m
[31m-             return int(255 + (time_ms - 500) * 0.1)  # 255+ pour >500ms[m
[31m-     [m
[31m-     def hz_to_magicstomp_rate(self, rate_hz: float) -> int:[m
[31m-         """[m
[31m-         Convertit une fr√©quence en Hz vers la valeur Magicstomp.[m
[31m-         [m
[31m-         Args:[m
[31m-             rate_hz: Fr√©quence en Hz[m
[31m-             [m
[31m-         Returns:[m
[31m-             Valeur Magicstomp pour la fr√©quence[m
[31m-         """[m
[31m-         # Magicstomp utilise une √©chelle logarithmique pour les fr√©quences[m
[31m-         if rate_hz <= 0:[m
[31m-             return 0[m
[31m-         [m
[31m-         # Mapping approximatif: 0.1-20 Hz -> 0-127[m
[31m-         import math[m
[31m-         if rate_hz < 0.1:[m
[31m-             return 0[m
[31m-         elif rate_hz <= 20:[m
[31m-             return int(127 * (math.log10(rate_hz / 0.1) / math.log10(200)))[m
[31m-         else:[m
[31m-             return 127[m
[31m-     [m
[31m-     def map_amp_parameters(self, amp_config: Dict[str, Any]) -> Dict[str, int]:[m
[31m-         """[m
[31m-         Mappe les param√®tres d'amplificateur vers les valeurs Magicstomp.[m
[31m-         [m
[31m-         Args:[m
[31m-             amp_config: Configuration d'amp du JSON[m
[31m-             [m
[31m-         Returns:[m
[31m-             Dictionnaire des param√®tres Magicstomp[m
[31m-         """[m
[31m-         print("üé∏ Mapping param√®tres amplificateur...")[m
[31m-         [m
[31m-         model_name = amp_config.get("model", "JCM800")[m
[31m-         amp_model_id = self.amp_models.get(model_name, 0x03)[m
[31m-         [m
[31m-         cab_name = amp_config.get("cab", "2x12_ALNICO")[m
[31m-         cab_model_id = self.cab_models.get(cab_name, 0x03)[m
[31m-         [m
[31m-         params = {[m
[31m-             "amp_model": amp_model_id,[m
[31m-             "cab_model": cab_model_id,[m
[31m-             "gain": self.float_to_magicstomp_value(amp_config.get("gain", 0.5)),[m
[31m-             "bass": self.float_to_magicstomp_value(amp_config.get("bass", 0.5)),[m
[31m-             "mid": self.float_to_magicstomp_value(amp_config.get("mid", 0.5)),[m
[31m-             "treble": self.float_to_magicstomp_value(amp_config.get("treble", 0.5)),[m
[31m-             "presence": self.float_to_magicstomp_value(amp_config.get("presence", 0.5)),[m
[31m-             "master": self.float_to_magicstomp_value(amp_config.get("master", 0.7))[m
[32m+ [m
[32m+         # Mapping JSON ‚Üí (effet, param√®tre, transformation)[m
[32m+         self.parameter_mappings: Dict[Tuple[str, str], _MappingEntry] = {[m
[32m+             # Amplificateur (AmpMultiFlange regroupe les contr√¥les amp)[m
[32m+             ("amp", "model"): _MappingEntry([m
[32m+                 "AmpMultiFlange", "Amp Type", self._transform_amp_model[m
[32m+             ),[m
[32m+             ("amp", "gain"): _MappingEntry([m
[32m+                 "AmpMultiFlange", "Gain", self._transform_normalized[m
[32m+             ),[m
[32m+             ("amp", "bass"): _MappingEntry([m
[32m+                 "AmpMultiFlange", "Bass", self._transform_normalized[m
[32m+             ),[m
[32m+             ("amp", "mid"): _MappingEntry([m
[32m+                 "AmpMultiFlange", "Middle", self._transform_normalized[m
[32m+             ),[m
[32m+             ("amp", "treble"): _MappingEntry([m
[32m+                 "AmpMultiFlange", "Treble", self._transform_normalized[m
[32m+             ),[m
[32m+             ("amp", "presence"): _MappingEntry([m
[32m+                 "AmpMultiFlange", "Presence", self._transform_normalized[m
[32m+             ),[m
[32m+             # Delay (MonoDelay)[m
[32m+             ("delay", "time_ms"): _MappingEntry([m
[32m+                 "MonoDelay", "Time", self._transform_delay_time[m
[32m+             ),[m
[32m+             ("delay", "feedback"): _MappingEntry([m
[32m+                 "MonoDelay", "Feedback", self._transform_normalized[m
[32m+             ),[m
[32m+             ("delay", "mix"): _MappingEntry([m
[32m+                 "MonoDelay", "Level", self._transform_normalized[m
[32m+             ),[m
[32m+             # Reverb[m
[32m+             ("reverb", "type"): _MappingEntry([m
[32m+                 "Reverb", "Type", self._transform_reverb_type[m
[32m+             ),[m
[32m+             ("reverb", "decay_s"): _MappingEntry([m
[32m+                 "Reverb", "Decay", self._transform_reverb_decay[m
[32m+             ),[m
[32m+             ("reverb", "mix"): _MappingEntry([m
[32m+                 "Reverb", "Mix", self._transform_normalized[m
[32m+             ),[m
[32m+             # Modulation : on se base sur l'effet Chorus pour la vitesse/profondeur[m
[32m+             ("mod", "rate_hz"): _MappingEntry([m
[32m+                 "Chorus", "Frequency", self._transform_mod_rate[m
[32m+             ),[m
[32m+             ("mod", "depth"): _MappingEntry([m
[32m+                 "Chorus", "Depth", self._transform_normalized[m
[32m+             ),[m
[32m+             ("mod", "mix"): _MappingEntry([m
[32m+                 "Chorus", "Feedback", self._transform_normalized[m
[32m+             ),[m
          }[m
[32m++<<<<<<< HEAD[m
[32m +        [m
[32m +        print(f"   Mod√®le: {model_name} (ID: {amp_model_id})")[m
[32m +        print(f"   Cabine: {cab_name} (ID: {cab_model_id})")[m
[32m +        print(f"   Gain: {params['gain']}, EQ: B={params['bass']} M={params['mid']} T={params['treble']} P={params['presence']}")[m
[32m +        [m
[32m +        return params[m
[32m +    [m
[32m +    def map_booster_parameters(self, booster_config: Dict[str, Any]) -> Dict[str, int]:[m
[32m +        """[m
[32m +        Mappe les param√®tres de booster vers les valeurs Magicstomp.[m
[32m +        [m
[32m +        Args:[m
[32m +            booster_config: Configuration de booster du JSON[m
[32m +            [m
[32m +        Returns:[m
[32m +            Dictionnaire des param√®tres Magicstomp[m
[32m +        """[m
[32m +        print("üöÄ Mapping param√®tres booster...")[m
[32m +        [m
[32m +        booster_type_name = booster_config.get("type", "CLEAN")[m
[32m +        booster_type_id = self.booster_types.get(booster_type_name, 0x03)[m
[32m +        [m
[32m +        params = {[m
[32m +            "booster_type": booster_type_id,[m
[32m +            "booster_level": self.float_to_magicstomp_value(booster_config.get("level", 0.3)),[m
[32m +            "booster_enabled": 1 if booster_config.get("enabled", True) else 0[m
[32m +        }[m
[32m +        [m
[32m +        print(f"   Type: {booster_type_name} (ID: {booster_type_id})")[m
[32m +        print(f"   Level: {params['booster_level']}")[m
[32m +        [m
[32m +        return params[m
[32m +    [m
[32m +    def map_delay_parameters(self, delay_config: Dict[str, Any]) -> Dict[str, int]:[m
[32m +        """[m
[32m +        Mappe les param√®tres de delay vers les valeurs Magicstomp.[m
[32m +        [m
[32m +        Args:[m
[32m +            delay_config: Configuration de delay du JSON[m
[32m +            [m
[32m +        Returns:[m
[32m +            Dictionnaire des param√®tres Magicstomp[m
[32m +        """[m
[32m +        print("‚è∞ Mapping param√®tres delay...")[m
[32m +        [m
[32m +        enabled = delay_config.get("enabled", False)[m
[32m +        if not enabled:[m
[32m +            return {"delay_enabled": 0}[m
[32m +        [m
[32m +        time_ms = delay_config.get("time_ms", 300)[m
[32m +        feedback = delay_config.get("feedback", 0.3)[m
[32m +        mix = delay_config.get("mix", 0.2)[m
[32m +        [m
[32m +        params = {[m
[32m +            "delay_enabled": 1,[m
[32m +            "delay_time": self.ms_to_magicstomp_time(time_ms),[m
[32m +            "delay_feedback": self.float_to_magicstomp_value(feedback),[m
[32m +            "delay_mix": self.float_to_magicstomp_value(mix),[m
[32m +            "delay_type": 0x01,  # Digital delay par d√©faut[m
[32m +            "delay_tempo_sync": 0  # Pas de sync tempo par d√©faut[m
[32m +        }[m
[32m +        [m
[32m +        print(f"   Temps: {time_ms}ms -> {params['delay_time']}")[m
[32m +        print(f"   Feedback: {feedback:.2f} -> {params['delay_feedback']}")[m
[32m +        print(f"   Mix: {mix:.2f} -> {params['delay_mix']}")[m
[32m +        [m
[32m +        return params[m
[32m +    [m
[32m +    def map_reverb_parameters(self, reverb_config: Dict[str, Any]) -> Dict[str, int]:[m
[32m +        """[m
[32m +        Mappe les param√®tres de reverb vers les valeurs Magicstomp.[m
[32m +        [m
[32m +        Args:[m
[32m +            reverb_config: Configuration de reverb du JSON[m
[32m +            [m
[32m +        Returns:[m
[32m +            Dictionnaire des param√®tres Magicstomp[m
[32m +        """[m
[32m +        print("üèõÔ∏è Mapping param√®tres reverb...")[m
[32m +        [m
[32m +        enabled = reverb_config.get("enabled", False)[m
[32m +        if not enabled:[m
[32m +            return {"reverb_enabled": 0}[m
[32m +        [m
[32m +        reverb_type_name = reverb_config.get("type", "PLATE")[m
[32m +        reverb_type_id = self.reverb_types.get(reverb_type_name, 0x02)[m
[32m +        [m
[32m +        decay_s = reverb_config.get("decay_s", 1.5)[m
[32m +        mix = reverb_config.get("mix", 0.15)[m
[32m +        [m
[32m +        params = {[m
[32m +            "reverb_enabled": 1,[m
[32m +            "reverb_type": reverb_type_id,[m
[32m +            "reverb_decay": self.float_to_magicstomp_value(decay_s / 3.0),  # Normalise sur 3s max[m
[32m +            "reverb_mix": self.float_to_magicstomp_value(mix),[m
[32m +            "reverb_predelay": 0,  # Pas de predelay par d√©faut[m
[32m +            "reverb_high_cut": 127  # Pas de filtrage par d√©faut[m
[32m +        }[m
[32m +        [m
[32m +        print(f"   Type: {reverb_type_name} (ID: {reverb_type_id})")[m
[32m +        print(f"   Decay: {decay_s:.1f}s -> {params['reverb_decay']}")[m
[32m +        print(f"   Mix: {mix:.2f} -> {params['reverb_mix']}")[m
[32m +        [m
[32m +        return params[m
[32m +    [m
[32m +    def map_mod_parameters(self, mod_config: Dict[str, Any]) -> Dict[str, int]:[m
[32m +        """[m
[32m +        Mappe les param√®tres de modulation vers les valeurs Magicstomp.[m
[32m +        [m
[32m +        Args:[m
[32m +            mod_config: Configuration de modulation du JSON[m
[32m +            [m
[32m +        Returns:[m
[32m +            Dictionnaire des param√®tres Magicstomp[m
[32m +        """[m
[32m +        print("üåä Mapping param√®tres modulation...")[m
[32m +        [m
[32m +        enabled = mod_config.get("enabled", False)[m
[32m +        if not enabled:[m
[32m +            return {"mod_enabled": 0}[m
[32m +        [m
[32m +        mod_type_name = mod_config.get("type", "CHORUS")[m
[32m +        mod_type_id = self.mod_types.get(mod_type_name, 0x01)[m
[32m +        [m
[32m +        rate_hz = mod_config.get("rate_hz", 0.8)[m
[32m +        depth = mod_config.get("depth", 0.35)[m
[32m +        mix = mod_config.get("mix", 0.18)[m
[32m +        [m
[32m +        params = {[m
[32m +            "mod_enabled": 1,[m
[32m +            "mod_type": mod_type_id,[m
[32m +            "mod_rate": self.hz_to_magicstomp_rate(rate_hz),[m
[32m +            "mod_depth": self.float_to_magicstomp_value(depth),[m
[32m +            "mod_mix": self.float_to_magicstomp_value(mix),[m
[32m +            "mod_tempo_sync": 0  # Pas de sync tempo par d√©faut[m
[32m +        }[m
[32m +        [m
[32m +        print(f"   Type: {mod_type_name} (ID: {mod_type_id})")[m
[32m +        print(f"   Rate: {rate_hz:.1f}Hz -> {params['mod_rate']}")[m
[32m +        print(f"   Depth: {depth:.2f} -> {params['mod_depth']}")[m
[32m +        print(f"   Mix: {mix:.2f} -> {params['mod_mix']}")[m
[32m +        [m
[32m +        return params[m
[32m +    [m
[32m +    def create_syx_header(self, command: int, patch_number: int = 0) -> List[int]:[m
[32m +        """[m
[32m +        Cr√©e l'en-t√™te SysEx pour le Magicstomp.[m
[32m +        [m
[32m +        Args:[m
[32m +            command: Commande SysEx (0x20 pour lecture, 0x40 pour √©criture)[m
[32m +            patch_number: Num√©ro du patch (0-99)[m
[32m +            [m
[32m +        Returns:[m
[32m +            Liste des bytes d'en-t√™te[m
[32m +        """[m
[32m +        return [[m
[32m +            0xF0,  # SysEx start[m
[32m +            self.MANUFACTURER_ID,  # Yamaha[m
[32m +            self.DEVICE_ID,  # Device ID[m
[32m +            self.MAGICSTOMP_ID,  # Magicstomp ID[m
[32m +            command,  # Commande[m
[32m +            patch_number,  # Num√©ro de patch[m
[32m +        ][m
[32m +    [m
[32m +    def create_patch_data(self, all_params: Dict[str, int]) -> List[int]:[m
[32m +        """[m
[32m +        Cr√©e les donn√©es de patch √† partir des param√®tres mapp√©s.[m
[32m +        [m
[32m +        Args:[m
[32m +            all_params: Tous les param√®tres mapp√©s[m
[32m +            [m
[32m +        Returns:[m
[32m +            Liste des bytes de donn√©es[m
[32m +        """[m
[32m +        # Structure de donn√©es Magicstomp (simplifi√©e)[m
[32m +        # Dans un vrai adaptateur, il faudrait la documentation compl√®te[m
[32m +        patch_data = [][m
[32m +        [m
[32m +        # Section Amplificateur[m
[32m +        patch_data.extend([[m
[32m +            all_params.get("amp_model", 0x03),[m
[32m +            all_params.get("cab_model", 0x03),[m
[32m +            all_params.get("gain", 64),[m
[32m +            all_params.get("bass", 64),[m
[32m +            all_params.get("mid", 64),[m
[32m +            all_params.get("treble", 64),[m
[32m +            all_params.get("presence", 64),[m
[32m +            all_params.get("master", 89),[m
[32m +        ])[m
[32m +        [m
[32m +        # Section Booster[m
[32m +        patch_data.extend([[m
[32m +            all_params.get("booster_enabled", 0),[m
[32m +            all_params.get("booster_type", 0x03),[m
[32m +            all_params.get("booster_level", 38),[m
[32m +        ])[m
[32m +        [m
[32m +        # Section Delay[m
[32m +        patch_data.extend([[m
[32m +            all_params.get("delay_enabled", 0),[m
[32m +            all_params.get("delay_type", 0x01),[m
[32m +            all_params.get("delay_time", 96),  # 300ms approximatif[m
[32m +            all_params.get("delay_feedback", 38),[m
[32m +            all_params.get("delay_mix", 25),[m
[32m +            all_params.get("delay_tempo_sync", 0),[m
[32m +        ])[m
[32m +        [m
[32m +        # Section Reverb[m
[32m +        patch_data.extend([[m
[32m +            all_params.get("reverb_enabled", 0),[m
[32m +            all_params.get("reverb_type", 0x02),[m
[32m +            all_params.get("reverb_decay", 64),[m
[32m +            all_params.get("reverb_mix", 19),[m
[32m +            all_params.get("reverb_predelay", 0),[m
[32m +            all_params.get("reverb_high_cut", 127),[m
[32m +        ])[m
[32m +        [m
[32m +        # Section Modulation[m
[32m +        patch_data.extend([[m
[32m +            all_params.get("mod_enabled", 0),[m
[32m +            all_params.get("mod_type", 0x01),[m
[32m +            all_params.get("mod_rate", 10),[m
[32m +            all_params.get("mod_depth", 44),[m
[32m +            all_params.get("mod_mix", 23),[m
[32m +            all_params.get("mod_tempo_sync", 0),[m
[32m +        ])[m
[32m +        [m
[32m +        # Padding pour atteindre la taille de patch Magicstomp[m
[32m +        # (taille approximative bas√©e sur MagicstompFrenzy)[m
[32m +        while len(patch_data) < 128:[m
[32m +            patch_data.append(0x00)[m
[32m +        [m
[32m +        return patch_data[:128]  # Limite √† 128 bytes[m
[32m +    [m
[32m +    def calculate_checksum(self, data: List[int]) -> int:[m
[32m +        """[m
[32m +        Calcule le checksum SysEx pour le Magicstomp (comme MagicstompFrenzy).[m
[32m +        [m
[32m +        Args:[m
[32m +            data: Donn√©es √† v√©rifier[m
[32m +            [m
[32m +        Returns:[m
[32m +            Checksum calcul√©[m
[32m +        """[m
[32m +        # Checksum additif avec n√©gation (comme MagicstompFrenzy)[m
[32m +        checksum = 0[m
[32m +        for byte in data:[m
[32m +            checksum += byte[m
[32m +        return (-checksum) & 0x7F  # N√©gatif + masque sur 7 bits[m
[32m +    [m
[32m +    def create_realtime_parameter_message(self, offset: int, value: int) -> List[int]:[m
[32m +        """[m
[32m +        Cr√©e un message SysEx pour modification temps r√©el d'un param√®tre.[m
[32m +        Compatible avec le format de MagicstompFrenzy.[m
[32m +        [m
[32m +        Args:[m
[32m +            offset: Position du param√®tre dans le patch (0-158)[m
[32m +            value: Nouvelle valeur du param√®tre (0-127)[m
[32m +            [m
[32m +        Returns:[m
[32m +            Message SysEx complet[m
[32m +        """[m
[32m +        # Header pour modification temps r√©el (comme MagicstompFrenzy)[m
[32m +        message = [[m
[32m +            0xF0, 0x43, 0x7D, 0x40, 0x55, 0x42,  # Header temps r√©el[m
[32m +            0x20,  # Commande modification param√®tre[m
[32m +        ][m
[32m +        [m
[32m +        # D√©termine la section (commune ou effet)[m
[32m +        PATCH_COMMON_LENGTH = 0x20  # 32 bytes[m
[32m +        if offset < PATCH_COMMON_LENGTH:[m
[32m +            message.append(0x00)  # Section commune[m
[32m +            message.append(offset